:toc: macro
toc::[]

:doctype: book
:reproducible:
:source-highlighter: rouge
:listing-caption: Listing

== The Integration Module

=== Introduction

Within the _Enterprise architecture_ the *integration* (or https://en.wikipedia.org/wiki/Enterprise_integration[Enterprise Integration]) is the field focused on communication between systems: system interconnection, electronic data interchange, product data exchange, distributed computing environments, etc. So the _integration_ defines and provides an infrastructure to allow the communication between different applications or systems in a reliable way. The scope of _Integration_ groups a wide range of communication methods, the systems can communicate by file transfer, sharing a data base, by remote procedure invocation or by messaging. The approach of the _Integration Module_ implementation is based on the latter, using a solution based on _channels_ and message _queues_ to allow the exchange of information between applications.

=== Stack of technologies

The _Integration IP Module_ is a Java module based on https://projects.spring.io/spring-integration/[Spring Integration] solution and internally is implemented using the https://github.com/spring-projects/spring-integration-java-dsl/wiki/spring-integration-java-dsl-reference[Spring integration Java dsl reference]. In the core of all those technologies the implementation relies on the https://en.wikipedia.org/wiki/Java_Message_Service[Java Message Service (JMS)] as the messaging standard to create, send, receive and read messages.

- *Java Message Service*: JMS allows applications to exchange messages using reliable and loosely coupled communication. To achieve this, the communication is done through message queues so the different applications (message server, and message clients) don’t know the actual addresses of each other, so they work in an emitter/subscriber manner.  To manage those message queues, that are "out" of the applications but should be accessible, the solution provided by Devon relies on a message broker that will be in charge of messages infrastructure.

- *Apache Active MQ*: The _channels_, _queues_ and _messages_ that the solution is based on, need an external infrastructure to be supported. The Devonfw implementation relies on http://activemq.apache.org/[Apache Active MQ] as the message broker to manage the messages and queues that the different applications will use as communication channel. _Active MQ_ is an open source infrastructure that is one of the most popular messaging servers and provides fully support for _JMS_.

- *Spring Integration* extends the Spring framework to support the Enterprise Integration (system interconnection, electronic data interchange, product data exchange and distributed computing environments). Spring Integration enables lightweight messaging within Spring-based applications providing a simple model for building enterprise integration solutions while maintaining the separation of concerns. Among its features Spring Integration provides JMS support through Channel Adapters for receiving JMS messages.

- The *Java DSL extension for Spring Integration* provides a set of convenient Builders and a fluent API to configure Spring Integration message flows from Spring configuration classes. It allows the creation of channel/queues and the message flow in applications start up time, so users can avoid the standard Spring Integration XML configuration (although it can also be used along side the DSL definitions).

=== Installing Apache Active MQ

==== How to get and install the message broker

If you want to be ready to a quick test of the module you will need an _Active MQ_ broker. To do so you can download the _Active MQ_ message broker from the http://activemq.apache.org/download.html[official site]. After the download is over, extract the zip folder, open a command line window and go to the _bin_ folder inside the just created _apache-activemq-{version}_ folder.

[source,bash]
----
your\location\apache-activemq-5.14.3>cd bin
----

And start the server from the bin folder

[source,bash]
----
your\location\apache-activemq-5.14.3\bin>activemq start
----

Now open a browser and access to url `http://localhost:8161/admin`, fill the access login with `admin` for both _user_ and _password_.

image::images/integration/activemq_access.png[,width="450", link="images/integration/activemq_access.png"]

After logging in, you will have access to all the infrastructure of the message server

image::images/integration/activemq_client.png[,width="450", link="images/integration/activemq_client.png"]

[NOTE]
====
We are installing the Active MQ server in our local machine only for test or example purposes. If you want further configuration details please visit the http://activemq.apache.org/configuration.html[official documentation] or ask your IT department.
====

=== Using Apache Active MQ with Docker

Active MQ can also be run with Docker, you will need to:

 - Create a folder on your machine for a shared volume with the container (`c:/Users/docker/activemq` on the example below)
 - Create an `activemq.xml` configuration file (`c:/Users/docker/activemq/conf/activemq.xml` on the example below)
 - Run the following command

[source]
----
docker run --rm -p 61616:61616 -p 8161:8161 -v c:/Users/docker/activemq/conf:/etc/activemq/conf -v c:/Users/docker/activemq/data:/var/activemq/data rmohr/activemq:5.14.3-alpine
----

For the `activemq.xml` file, you can use the following content (extracted from sample folder on activemq distribution)

[source,xml]
----
<beans
  xmlns="http://www.springframework.org/schema/beans"
  xmlns:amq="http://activemq.apache.org/schema/core"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
  http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core.xsd
  http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd">

  
  <broker xmlns="http://activemq.apache.org/schema/core" useJmx="false">

    <persistenceFactory>
      <journalPersistenceAdapterFactory journalLogFiles="5" dataDirectory="../data"/>
    </persistenceFactory>
  
    <transportConnectors>
      <transportConnector uri="tcp://localhost:61616"/>      
      <transportConnector uri="stomp://localhost:61613"/>
    </transportConnectors>
        
  </broker>
  
</beans>

----


==== Module connection configuration

The _Integration module_ provides a default connection configuration for Active MQ broker through the following properties

[source]
----
spring.activemq.broker-url=tcp://localhost:61616
spring.activemq.user=admin
spring.activemq.password=admin
----

If you have changed the _Active MQ_ configuration remember to overwrite the affected properties in the `application.properties` of your project.

=== IP Integration module details

==== Adding the starter to a project
To access the functionality of the _Integration module_, you will need to include its starter in your project's pom.xml. Verify that the _version_ matches the last available version of the module.

[source,xml]
----
 <dependency>
      <groupId>com.capgemini.devonfw.starter</groupId>
      <artifactId>devonfw-integration-starter</artifactId>
      <version>${devonfw.version}</version>
</dependency>
----

[WARNING]
====
The IP modules of Devonfw are stored in https://www.jfrog.com/artifactory/[Artifactory]. In case, you do not have access to that repository, as the modules are included in the Devonfw distribution, you can install them manually. To do so, open a Devonfw command line (_console.bat_), go to `Devon-dist\workspaces\examples\devon\modules` and execute the command `mvn install`.
If the project is already imported in Eclipse then update project: Right click on _project_ > _Maven_ > _Update Project_ > check the _Force update of Snapshot/Releases_ checkbox > _Ok_
====

==== Injecting the module

After adding the dependency, in order to start using the module inject it using the `@Inject` annotation

[source,java]
----
import com.capgemini.devonfw.module.integration.common.api.Integration;

...

  @Inject
  private Integration integration;
----

We will see the detailed usage of the module in the upcoming sections.

==== Default channels

Based on the mentioned stack of technologies, the Devonfw _Integration module_ provides three communication channels pre-configured and ready to be used out-of-the-box. The user will only need to _enable_ it through the module configuration.

===== Simple message channel

This is the most basic communication channel. In this case in one side is an application (_emitter_) that sends messages to a specific queue in the message broker. In the other side a second application (_subscriber_) is _subscribed_ to that channel, which means that polls the message broker in a defined interval of time to ask for new messages in that particular queue.

image::images/integration/simple_channel.png[,width="450", link="images/integration/simple_channel.png"]

The _subscriber_ application doesn't provide a response, only consumes the messages.

To configure your application to use this default channel you only need to edit the `application.properties` of your Spring project adding the property `devonfw.integration.one-direction.emitter` or `devonfw.integration.one-direction.subscriber`.

For emitter applications set the _one-direction.emitter_ property to _true_:

[source]
----
devonfw.integration.one-direction.emitter=true
----

If your application acts as subscriber set the property _one-direction.subscriber to _true_:

[source]
----
devonfw.integration.one-direction.subscriber=true
----

Doing this, when running your app the related _Beans_ will be loaded automatically and the communication channel and its related queue will be also created.

We will see more details of the simple message channel configuration further.

===== Request-Reply channel 

In this second approach the message flow is completed in two directions. In this case, instead of talking about an _emitter_ and _subscriber_ systems, we should rather talk about a _request/replay_ channel. There will exist a communication between two clients, in which the first one will send a message and wait for a response from the second one. So both sides are _emitters_ and _subscriber_.

image::images/integration/requestreply_channel.png[,width="450", link="images/integration/requestreply_channel.png"]

To configure your application to use this default channel, as we explained in the previous section, you only need to edit the `application.properties` of your Spring project adding in this case the property `devonfw.integration.request-reply.emitter` or `devonfw.integration.request-reply.subscriber`.

For emitter/subscriber applications set the _request-reply.emitter_ property to _true_:

[source]
----
devonfw.integration.request-reply.emitter=true
----

If your application acts as subscriber/emitter set the property _request-reply.subscriber_ to _true_:

[source]
----
devonfw.integration.request-reply.subscriber=true
----

Doing this, same as in the previous case, when running your app the related _Beans_ will be loaded automatically and the communication channel and its related queue will be also created.

We also will see more details of the simple message channel configuration further.

===== Request-Reply asynchronous channel

For the cases where the previous _request/reply_ communication has to be _asynchronous_ the module provides a default _async_ communication channel.

To configure your application to use this asynchronous channel, as in the previous cases, you only need to enable the corresponding properties into the `application.properties` file of your project.

For emitter/subscriber applications set the _request-reply-async.emitter_ property to _true_:

[source]
----
devonfw.integration.request-reply-async.emitter=true
----

Otherwise, if your application is the subscriber/emitter, set the property _request-reply.subscriber_ to _true_:

[source]
----
devonfw.integration.request-reply-async.subscriber=true
----

We will show the complete configuration of this default channel in upcoming sections.


==== Usage of the default channels

===== How to use the default simple channel

As we previously mentioned the _Integration module_ provides a simple communication channel where in one side one _emitter_ application will send a message and in the other side other _subscriber_ application will receive and read it.

To achieve that in our applications we only need to configure the corresponding properties to create the channel and its related queue.

*Default configuration*

The default configuration properties for this channel, provided by default with the _Integration module_, are:

[source]
----
devonfw.integration.one-direction.emitter=false
devonfw.integration.one-direction.subscriber=false
devonfw.integration.one-direction.channelname=1d.Channel
devonfw.integration.one-direction.queuename=1d.queue
devonfw.integration.one-direction.poller.rate=5000
----

- _emitter_: if your app is going to send messages through this channel to the related queue.
- _subscriber_ if your app is going to subscribe to the channel to read the messages of the queue.
- _channelname_: the name for the channel.
- _queuename_: the name for the channel queue.
- _poller.rate_: in case of subscriber applications this is the interval to poll the message broker for new messages.

If you want to customize these properties you can overwrite them in the `application.properties` of your project.

*Emitter application configuration*

As we already mentioned the _Emitter_ applications must enable the _emitter_ property so you must add to the `application.properties` file of your project the property

[source]
----
devonfw.integration.one-direction.emitter=true
----

Optionally, you can edit the name for the channel and for the queue using the `devonfw.integration.one-direction.channelname` and `devonfw.integration.one-direction.queuename` properties.

*Emitter application example*

After you have added the <<Adding the starter to a project,module dependency>> you can start using the module <<Injecting the module,injecting it>> in your app. Lets see how to send a simple message through that default _simple channel_.

[NOTE]
====
In order to make the example run properly remember that we will need an <<Installing Apache Active MQ,Active MQ>> instance running to provide support to the _channels_ and _queues_.
====

In our _sender_ application we only need to call the _send_ method of the _integration_ object and provide a message content

[source,java]
----
import com.capgemini.devonfw.module.integration.common.api.Integration;

public class MyEmitterApp{

  @Inject
  private Integration integration;

  public void sendSimpleMessage(){

    this.integration.send("hello world");
  }

}
----

Running the application will result into a message sent to the _Integration module_ default _simple channel_ with name `1d.Channel` and to the queue `1d.queue` (or the names you provided through configuration properties). So if now we go to the Active MQ web client we will see in the `Queues` section that we have a new queue created with one message as _pending messages_, no _consumers_ (as we still don't have any subscriber to this _channel/queue_) and no _dequeued messages_. 

image::images/integration/activemq_simplechannel_send.png[,width="450", link="images/integration/activemq_simplechannel_send.png"]

Clicking on the queue name shows us the pending messages details

image::images/integration/activemq_simplechannel_message.png[,width="450", link="images/integration/activemq_simplechannel_message.png"]

And clicking again on the _message ID_ takes us to the _message view_ where we can see more details like the message content

image::images/integration/activemq_simplechannel_message2.png[,width="450", link="images/integration/activemq_simplechannel_message2.png"]

With this we have finished the _out flow_ for the _Integration module_ default _simple channel_. Lets see now how to read that message we have sent using a different application.

*Subscriber application configuration*

For _subscriber_ applications you must enable the channel through the corresponding property in the `application.properties` file of your project. 

[source]
----
devonfw.integration.one-direction.subscriber=true
----

In case of _subscriber_ applications you can also configure the interval of time to make the requests to the message broker for new messages. To do so you can add the property `devonfw.integration.one-direction.poller.rate` to your `application.properties` file and provide a milliseconds amount as property value. If you don't overwrite this property its default value is _5000_ (5 seconds).

As in the _emitter_ case, you can edit the name for both the _channel_ and the _queue_ (`devonfw.integration.one-direction.channelname` and `devonfw.integration.one-direction.queuename` properties) but have into account that *these names must match* between the _emitter_ and the _subscriber_ applications in order to perform the communication.

*Subscriber application example*

As in the case of _emitter_ application you have to add the <<Adding the starter to a project,module dependency>> and <<Injecting the module,inject>> the module. Once that is done we can subscribe our application to the _channel/queue_ to start receiving messages from the _Integration module_ default simple channel.

[source,java]
----
import com.capgemini.devonfw.module.integration.common.api.Integration;

public class MySubscriberApp{

  @Inject
  private Integration integration;

  @Inject
  private SubscriptionHandler subscriptionHandler;

  public void readSimpleMessage(){

    this.integration.subscribe(this.subscriptionHandler);
  }
}
----

In this case we provide to the `subscribe` method a _Subscription Handler_ to manage what we want to do with each message. For the example we have implemented a basic subscription handler. To create your own _Subscription Handler_ you only need to create a class, annotate it with `@Component` and implement the `SubscriptionHandler` interface. Lets see our _SubscriptionHandlerImp_

[source,java]
----
@Component
public class SubscriptionHandlerImp implements SubscriptionHandler {

  public void handleMessage(Message<?> message) throws MessagingException {

    System.out.println("***********************************");
    System.out.println("MESSAGE IS: " + message.getPayload());
    System.out.println("***********************************");

  }

}
----

As you can see we are only showing, through console, the message content which we access through the `getPayload()` method. Now running the application we get the output

[source]
----
***********************************
MESSAGE IS: Hello world
***********************************
----

And going back to the Active MQ web client we can see the changes in the `Queues` section

image::images/integration/activemq_simplechannel_read.png[,width="450", link="images/integration/activemq_simplechannel_read.png"]

The first you should note is that now the _Number of Consumers_ is _1_ as we have subscribed an application to the channel. Then the _Pending Messages_ has changed to _0_ and the _Messages Dequeued_ has increased to _1_.

At this point we have finished the example for the _in flow_ of the _Integration module_ default _simple channel_. Now you have the whole picture of how a simple integration channel works with Devonfw _Integration module_ and _Active MQ_ server.

===== How to use the default request-reply channel

With the _Integration module_ a ready to be used _request-reply_ channel is provided by default. This channel will allow us to communicate systems sending and receiving messages in both sides. A first application will send a message and wait for a response, while a second application will receive the message sent by the first one and send back the response that the other app is waiting for.

To achieve that in our applications we only need to configure the corresponding properties to create the channel and its related queue.

===== Default configuration for request-reply channel

The default configuration properties for this channel, provided by default with the _Integration module_, are:

[source]
----
devonfw.integration.request-reply.emitter=false
devonfw.integration.request-reply.subscriber=false
devonfw.integration.request-reply.channelname=rr.Channel
devonfw.integration.request-reply.queuename=rr.queue
devonfw.integration.request-reply.receivetimeout=5000
----

- _emitter_: if your app is going to send and then receive messages through this channel.
- _subscriber_ if your app is going to receive and then send back messages using this channel.
- _channelname_: the name for the channel.
- _queuename_: the name for the channel queue.
- _receivetimeout_: in case of send + receive applications this is the maximum amount of milliseconds to receive a response from "the other side" of the channel. If this time is exceeded a timeout _Exception_ will be thrown.

If you want to customize these properties you can overwrite them in the `application.properties` of your project, as we are going to see below.

===== Sender-Receiver application configuration

To enable the sending of messages through this channel you must set the `request-reply.emitter` property to _true_ in the `application.properties` of our project.

[source]
----
devonfw.integration.request-reply.emitter=true
----

Optionally, you can edit the name for the channel and for the queue using the `devonfw.integration.request-reply.channelname` and `devonfw.integration.request-reply.queuename` properties. As we just mentioned, the timeout for the response can be edited adding the `devonfw.integration.request-reply.receivetimeout` property to our properties file and providing a milliseconds value. By default the timeout is _5000_ (5 seconds). 


===== Sender-Receiver application example

After you have added the <<Adding the starter to a project,module dependency>> you need to <<Injecting the module,inject it>>. Lets see how to send and receive a simple message through that default _request-reply_ channel.

[NOTE]
====
In order to make the example run properly remember that we will need an <<Installing Apache Active MQ,Active MQ>> instance running to provide support to the _channels_ and _queues_.
====

In our _sender-receiver_ application we only need to call the _sendAndReceive_ method of the _integration_ object and provide a message content

[source,java]
----
import com.capgemini.devonfw.module.integration.common.api.Integration;

public class MyFirstApp{

  @Inject
  private Integration integration;

  public void myMethod(){

    String response = this.integration.sendAndReceive("Hello");
    System.out.println("Response:" + response);
  }

}
----

If now we run the application we would get a _timeout exception_ as there is no one ready to provide a response within the defined timeout limit (5 seconds). So first, lets prepare our _other-side_ application.

===== Receiver-Sender application configuration

In this application we need to enable the `request-reply.subscriber` property so, in the `applications.property` file of our project, we must set to _true_ that property.

[source]
----
devonfw.integration.request-reply.subscriber=true
----

You can also edit the name for both the _channel_ and the _queue_ (`devonfw.integration.request-reply.channelname` and `devonfw.integration.request-reply.queuename` properties). But, as mentioned in previous section, have into account that *these names must match* between the _sernder-receiver_ and the _receiver-sender_ applications, in order to perform the communication.

===== Receiver-Sender application example

As in the case of _sender-receiver_ application, you have to add the <<Adding the starter to a project,module dependency>> and <<Injecting the module,inject>> the module. Once that is done we can subscribe our application to the _channel/queue_ to start receiving messages and sending responses from/to the _Integration module_ default request-reply channel.

[source,java]
----
import com.capgemini.devonfw.module.integration.common.api.Integration;

public class MySecondApp{

  @Inject
  private Integration integration;

  @Inject
  private RequestHandler requestHandler;

  public void myMethod(){

    this.integration.subscribeAndReply(this.requestHandler);
  }
}
----

In this case we provide to the `subscribeAndReply` method an _Request Handler_ to manage the responses to each message. For the example we have implemented a basic Request Handler, to create your own one you only need to create a class and implement the `RequestHandler` interface. Lets see our _RequestHandlerImp_

[source,java]
----
@Component
public class RequestHandlerImp implements RequestHandler {

  @Override
  public Object handleMessage(Message<?> m) {

    System.out.println("***********************************");
    System.out.println("MESSAGE IS: " + m.getPayload());
    System.out.println("***********************************");

    return m.getPayload().toString().concat(" World");
  }

}
----

As you can see we are simply printing the original message received, using the `getPayload()` method, and then replying adding to it "World".

At this point we can run that second application and see what happens through the Active MQ web client.

image::images/integration/activemq_rrchannel_subscriber.png[,width="450", link="images/integration/activemq_rrchannel_subscriber.png"]

The above image shows that the channel and queue for our request-reply channel have been created automatically and in the _Number of Consumers_ you can see that _1_ that refers to our application.

Now we can run the first application, as at this point we already have the second application ready to reply to the first one requests.

The output in the second application is as expected

[source]
----
***********************************
MESSAGE IS: Hello
***********************************
----

While the output in the first app is

[source]
----
Response:Hello World
----

If we check out again the Active MQ web client we can see that we still have one consumer (the second application) but now we have also one _Message Enqueued_ and one _Message Dequeued_.

image::images/integration/activemq_rrchannel_message.png[,width="450", link="images/integration/activemq_rrchannel_message.png"]


We have finished the demonstration for the default Request-Reply channel provided by the _Integration module_. Now we are going to see how to achieve the same but in an asynchronous way using the third default channel provided by the module: the _request-reply-async_ channel.

===== How to use the default asynchronous request-reply channel

The usage of this default channel, provided also by default within the _Integration module_, is the same than for previous channels, and specially regarding the default _request-reply_ channel explained in the previous section. Anyway let´s briefly show the basics about how to configure and use the asynchronous channel.

*Default properties for asynchronous channel*

[source]
----
devonfw.integration.request-reply-async.emitter=false
devonfw.integration.request-reply-async.subscriber=false
devonfw.integration.request-reply-async.channelname=async.Channel
devonfw.integration.request-reply-async.queuename=async.queue
devonfw.integration.request-reply-async.receivetimeout=5000
----

The properties are the same as in the simple _request-reply_ channel.

The application that is going to trigger the communication flow, sending a first message, must enable the `request-reply-async.emitter` property, setting _true_ as value.

[source]
----
devonfw.integration.request-reply-async.emitter=true
----

In the configuration of this application we can also define the timeout for the response. If exceeded, the process will be stopped and a _timeout exception_ will be thrown. This can be controlled with the property `devonfw.integration.request-reply-async.receivetimeout`

In the other side, the application that is subscribed to the channel and is going to receive the messages and reply to them, must have the property `request-reply-async.subscriber` defined as _true_.

[source]
----
devonfw.integration.request-reply-async.subscriber=true
----


*Sender-Receiver async example*

After you have added the <<Adding the starter to a project,module dependency>> you need to <<Injecting the module,inject it>>. Lets see how to send and receive asynchronously a message through that default _request-reply-async_ channel.

[NOTE]
====
In order to make the example run properly remember that we will need an <<Installing Apache Active MQ,Active MQ>> instance running to provide support to the _channels_ and _queues_.
====

In our _sender-receiver_ application we only need to call the _sendAndReceiveAsync_ method of the _integration_ object and provide a message content. As we are creating an asynchronous process we will use the Java http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html[Future] to handle the response. We will not complicate the example with too many details of Future's use so the code will look like the following

[source,java]
----
import com.capgemini.devonfw.module.integration.common.api.Integration;

public class MyFirstApp{

  @Inject
  private Integration integration;

  public void myMethod() throws InterruptedException, ExecutionException{

    Future<String> response = this.integration.sendAndReceiveAsync("Hello");
    System.out.println("Message sent.");
    while (!response.isDone()) {
      // things that you can do in parallel while waiting for the response
      System.out.println("Waiting...");
    }

    System.out.println("ASYNC RESPONSE: " + response.get());

  }

}
----

If now we run the application we would get a _timeout exception_ as there is no one ready to provide a response within the defined timeout limit (5 seconds). So first, lets prepare our _other-side_ application.

*Receiver-Sender async example*

As in the previous application, you have to add the <<Adding the starter to a project,module dependency>> and <<Injecting the module,inject>> the module. Once that is done we can subscribe our application to the _channel/queue_ (with the _subscribeAsync_ method) to start receiving asynchronously messages and sending responses from/to the _Integration module_ default request-reply-async channel.

[source,java]
----
import com.capgemini.devonfw.module.integration.common.api.Integration;

public class MySecondApp{

  @Inject
  private Integration integration;

  @Inject
  private RequestAsyncHandler RequestAsyncHandler;

  public void myMethod(){

    this.integration.subscribeAsync(this.RequestAsyncHandler);
  }
}
----

In this case we provide to the `subscribeAsync` method an _Request Async Handler_ to manage the responses to each message. For the example we have implemented a very simple Request Async Handler that blocks the process during 3 seconds to simulate a long process. To create your own _Request Async Handler_ you only need to create a class, annotate it with `@Component` and implement the `RequestAsyncHandler` interface. Lets see our _RequestAsyncHandlerImp_.

[source,java]
----
@Component
public class RequestAsyncHandlerImp implements RequestAsyncHandler {

  @Override
  public Object handleMessage(Message<?> m) {

    System.out.println("***********************************");
    System.out.println("MESSAGE IS: " + m.getPayload());
    System.out.println("***********************************");
    try {
      Thread.sleep(3000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    return m.getPayload().toString().concat(" World");
  }

}
----

As you can see we are simply printing the original message received, using the `getPayload()` method, and after the delay of 3 seconds, it returns a reply adding "World" to the original message.

Now we can run that second application, the channel and its _async.queue_ will be automatically created in the Active MQ broker and the new consumer (our second app) will be subscribed to that channel.

image::images/integration/activemq_rrachannel_subscriber.png[,width="450", link="images/integration/activemq_rrachannel_subscriber.png"]

If now we run the first application the output is

[source]
----
Message Sent.
[...]
Waiting...
Waiting...
Waiting...
ASYNC RESPONSE: Hello World
----

With this we have completed the example about the default asynchronous channel for the request-reply flow of the Devonfw _Integration module_.
 
Also here ends the content about the pre-configured part of the module. Next we will see how to create, programmatically, new channels and queues.

==== Creating new channels

The Devonfw _Integration module_ provides the option of creating new channels programmatically. The user can generate new channels and send and receive messages defining every step in Java code, without the necessity of configure anything.

===== Types of channels that can be created

The types are the same than the default channels. The user will be able to create

- simple channels: one app sends a message, other app receives the message.

- request-reply channels: a first app sends a message, a second app receives the message and sends a response, the first app receives the response.

- asynchronous request-reply channels: Same as the previous channel but with asynchronous behaviour.

===== Creating and using a new simple channel

After you have added the <<Adding the starter to a project,module dependency>> and <<Injecting the module,injected it>>you only need to call the _createChannel_ method and provide a _name_ for the channel and a _name_ for the related queue.

[source,java]
----
import com.capgemini.devonfw.module.integration.common.api.Integration;

public class MySenderApp{

  @Inject 
  private Integration integration;

  public void sendSimpleMessage(){

    IntegrationChannel myChannel = this.integration.createChannel("my-channel", "my-queue");
    Boolean sent = myChannel.send("Hello");
    if (sent) System.out.println("message successfully sent");
  }
}
----

Then, in the _subscriber_ application, after adding the <<Adding the starter to a project,module dependency>> and the <<Injecting the module,injection>> of it, we only need to use the _subscribeTo_ method and provide the name for the channel and the queue (that *must match* the provided names in the first application) and the _Subscription Handler_ to manage the received messages. For more details about the _Subscription Handler_ check out the <<Subscriber application example,subscriber application example>> section.

[source,java]
----
import com.capgemini.devonfw.module.integration.common.api.Integration;

public class MySubscriberApp{

  @Inject 
  private Integration integration;

  @Inject 
  private SubscriptionHandler subscriptionHandler;

  public void readSimpleMessage(){

    this.integration.subscribeTo("my-channel", "my-queue", this.subscriptionHandler);
  }
}
----

By default, the interval for polling the channel is _5000_ (5 seconds) and can be changed through property `devonfw.integration.default.poller.rate` in `application.properties` file. In addition, you can define that value when creating the channel passing the milliseconds timeout as a parameter

[source,java]
----
this.integration.subscribeTo("my-channel", "my-queue", this.subscriptionHandler, 10000);
----

===== Creating and using a new request-reply channel

In the app that is going to start the flow, after adding the <<Adding the starter to a project,module dependency>> and <<Injecting the module,injected it>>, you only need to call the _createRequestReplyChannel_ method and provide a _name_ for the channel, a _name_ for the related queue and, this part is slightly different from the rest of module implementation, you need to provide a _Response Handler_ that will manage the received response, as we do with subscriber applications.

[source,java]
----
import com.capgemini.devonfw.module.integration.common.api.Integration;

public class MyFirstApp{

  @Inject 
  private Integration integration;

  @Inject
  private ResponseHandler responseHandler;

  public void startCommunication(){

    IntegrationChannel myChannel = this.integration.createRequestReplyChannel("my-channel", "my-queue", this.responseHandler);
    Boolean sent = myChannel.send("Hello");
    if (sent) System.out.println("message successfully sent");
  }
}
----

The _ResponseHandler_ provided in the example above is similar than explained previously in this _Integration module_ chapter (<<Subscriber application example ,subscriber application example>>), except that it must be a `void` method.

[source,java]
----
public class ResponseHandlerimp implements ResponseHandler {

  @Override
  public void handleMessage(Message<?> m) {

    System.out.println("***********************************");
    System.out.println("MESSAGE IS: " + m.getPayload());
    System.out.println("***********************************");

    m.getPayload().toString().concat(" World");
  }

}
----

With this code we will create the _channel/queue_ infrastructure, send the message and provide a handler for the response. Now we need to define the second side of the flow to receive the message and provide a reply.

The timeout for the response can be configured through property `devonfw.integration.default.receivetimeout` in `application.properties` file, by default is set to _5000_ (5 seconds).

You can also configure it when creating the channel passing the _timeout_ as a parameter

[source,java]
----
IntegrationChannel myChannel = this.integration.createRequestReplyChannel("my-channel", "my-queue", this.responseHandler, 10000);
----

In a second application, after adding the <<Adding the starter to a project,module dependency>> and the <<Injecting the module,injection>> of it, we only need to use the _subscribeAndReplyTo_ method and provide the name for the channel and the queue (that *must match* the names provided in the first app) and the _Request Handler_ to manage the received messages. The implementation is the same as the one described in the <<Sender-Receiver application example,receiver application example>> section. So our sample code will look like

[source,java]
----
import com.capgemini.devonfw.module.integration.common.api.Integration;

public class MySecondApp{

  @Inject 
  private Integration integration;

  @Inject
  private RequestHandler requestHandler;

  public void startCommunication(){

    this.integration.subscribeAndReplyTo("my-channel", "my-queue", this.requestHandler);
  }
}
----

[NOTE]
====
Remember that if you run the first app before the subscriber app is running you will probably get a _timeout exception_.
====

===== Creating and using a new asynchronous request-reply channel

To create that type of channels the implementation is exactly the same than in the <<How to use the default request-reply channel,previous section>>. So in this section we are going to show only the code differences.

The first app will use the method _createAsyncRequestReplyChannel_ to create the channel, the rest is the same

[source,java]
----
IntegrationChannel demoAsyncChannel = 
    this.integration.createAsyncRequestReplyChannel("my-async-channel", "my-async-queue", this.responseHandler);
----

You can define your own values for the _ThreadPoolExecutor's core pool size_ and _response timeout_ adding the properties `devonfw.integration.default.poolsize` and `devonfw.integration.default.receivetimeout` to your `application.properties` file and providing a value.

However, you can also define those values when creating the channel

[source,java]
----
IntegrationChannel demoAsyncChannel = 
  this.integration.createAsyncRequestReplyChannel("my-async-channel", "my-async-queue", this.responseHandler, 15, 10000);
----

In the second app you can subscribe to the channel with the method _subscribeAndReplyAsyncTo_ and providing the names for the channel and queue (that *must match* with the names provided in the first application), and an _Request Async Handler_ to manage the messages and provide a reply.

[source,java]
----
import com.capgemini.devonfw.module.integration.common.api.Integration;

public class MySecondApp{
  @Inject 
  private Integration integration;

  @Inject
  private RequestAsyncHandler requestAsyncHandler;

  public void startCommunication(){

    this.integration.subscribeAndReplyAsyncTo("my-async-channel", "my-async-queue", this.RequestAsyncHandler);
  }
}
----

The implementation for the _Request Async Handler_ is explained <<Receiver-Sender async example,here>>.

==== Sending headers with the message

The _Integration module_ also allows to send headers alongside the message content. To do so you can use the methods provided by the module that accept a _Map_ as parameter for headers.

===== Creating the headers

You can create the message headers using a Java _Map_ object

[source,java]
----
Map headers = new HashMap();
headers.put("header1", "value1");
headers.put("header2", "value2");
----

===== Sending the headers

Each _send_ method provided with the module accepts a _Map_ object as parameter for the headers, so you can send it alongside the message content

- *default simple channel*: `integration.send("Hello", headers)`

- *default request-reply channel*: `integration.sendAndReceive("Hello", headers)`

- *default asynchronous request-reply channel*: `integration.sendAndReceiveAsync("Hello", headers)`

- *new created channels*: `new_channel.send("Hello", headers)`